# 类型与声明

## 类型

<img src="C:\Users\GaoWei\Desktop\C++笔记\picture\cpp类型.png" style="zoom:50%;" />

### 字符类型

* char：默认的字符类型，通常占8位，可容纳256个值。
* signed char：带有符号的char，8位情况下范围是 -127~127。
* unsigned char：不带符号的char，8位情况下范围是 0~255。
* wchar_t：用于存放 Unicode 等更大的字符集。
* char16_t：用于存放 UTF-16 等 16 位的字符集。
* char32_t：用于存放 UTF-32 等 32 位的字符集。

从本质来说，char 的行为与 signed char 一致或者与 unsigned char 一致，但这 3 种类型各不相同，不能混用这 3 种字符类型的指针。

**字符字面值常量**：单引号内的一个字符，如 'a' 和 '0' 等。

可以把字符集中的字符表示成一个 1~3 位的八进制数 （\后紧跟八进制数字）或者表示成一个十六进制数（\x后紧跟十六进制数字），例如：  

| 八进制 | 十六进制 | 十进制 | ASCII |
| ------ | -------- | ------ | ----- |
| '\6'   | '\x6'    | 6      | ACK   |
| '\60'  | '\x30'   | 48     | ‘0’   |
| '\137' | '\x05f'  | 95     | ‘_’   |



### 整数类型

整数字面值常量分为3种：十进制、八进制和十六进制。  
十六进制数值以 x 或 X （0x 或 0X） 开头；八进制数值以 0 开头但是后面没有 x 或 X，例如：  

| 十进制 | 八进制 | 十六进制 |
| ------ | ------ | -------- |
| 0      | 0      | 0x0      |
| 2      | 02     | 0x2      |
| 63     | 077    | 0x3f     |
| 83     | 0123   | 0x63     |



 ## 声明

### 声明的结构

* 可选的前置修饰符（如 static 和 virtual）
* 基本类型（如 vector<double> 和 const int）
* 可选的声明符，可包含一个名字 （如 p[7]、n 和 *(*)[]）
* 可选的后缀函数修饰符（如 const 和 noexcept）
* 可选的初始化器或函数体（如 ={7,5} 和 {renturn x;}）

声明符由一个名字和一些可选的声明运算符组成，常用的声明运算符包括： 

| 声明运算符 |           |               |
| ---------- | --------- | ------------- |
|            | *         | 指针          |
| 前缀       | *const    | 常量指针      |
| 前缀       | *volatile | volatile 指针 |
| 前缀       | &         | 左值引用      |
| 前缀       | &&        | 右值引用      |
| 前缀       | auto      | 函数          |
| 后缀       | []        | 数组          |
| 后缀       | ()        | 函数          |
| 后缀       | ->        | 从函数返回    |

后缀声明符的绑定效果比前缀声明符更紧密，例如  

```c++
char *kings[];		//char指针的数组
char (*kings)[];	//指向char数组的指针
```



### 作用域

* 局部作用域
* 类作用域
* 名字空间作用域
* 全局作用域
* 语句作用域
* 函数作用域

在块内声明的名字能隐藏外层块及全局作用域中的同名声明，可以使用作用域解析运算符 :: 访问被隐藏的全局名字，例如：  

```c++
int x;		//全局变量x

void f()
{
	int x;  	  //局部变量x，隐藏了全局变量x
	x = 1;		
	{
		int x;	  //隐藏了上一个局部变量x
		x = 2;		
		::x = 3;  //为全局变量x赋值
	}
	x = 4;
}
```

### 初始化

初始化器有四种可能的形式：  

```c++
X a1 {v};      //推荐使用这种方法，不受任何限制，在所有场景中都能使用
X a2 = {v};
X a3 = v;
X a4(v);
```

**列表初始化**：使用 {} 的初始化，能防止窄化转换，即：  

* 如果一种整型存不下另一种整型的值，则后者不会被转换成前者。（如允许 char 转化成 int，不允许 int 转化成 char）
* 如果一种浮点型存不下另一种浮点型的值，则后者不会被转换成前者。（如允许 float 转换成 double，不允许 double 转化成 float）
* 整型和浮现型不能互相转换

### 类型推断：auto 和 decltype()

* atuo 根据对象的初始化器推断对象的数据类型，可能是变量、const 或者 constexpr 的类型。
* decltype(expr) 推断的对象不是一个简单地初始化器，有可能是函数的返回类型或者类成员的类型。



## 对象和值

### 左值和右值



### 对象的生命周期

* 自动对象
* 静态对象
* 自由存储对象
* 临时对象
* 线程局部对象

## 类型别名

```c++
using int32_t = int;         //typedef int int32_t
using int16_t = short;		//typedef short int16_t
using PtoF = void(*)(int);   //typedef void(*PtoF)(int);
```




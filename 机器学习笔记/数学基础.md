## 函数

函数把一个集合里的每一个元素联系到另一个集合里一个独一的值。

## 梯度

梯度向量：函数变换最快的方向。

## 张量

张量：机器学习中，用于存储数据的结构。  
轴：张量的维度。  
阶：轴的个数。

### 标量——0D（阶）张量

**标量**：仅包含一个数字的张量

```python
import numpy as np #导入NumPy
X = np.array(5) # 创建0D张量，也就是标量
print("X的值",X)
print("X的阶",X.ndim) #ndim属性显示张量轴的个数
print("X的数据类型",X.dtype) # dtype属性显示张量数据类型
print("X的形状",X.shape) # shape属性显示张量形状

结果：
X的值 5
X的阶 0
X的数据类型 int32
X的形状 ()
```

### 向量——1D（阶）张量

**向量**：由一组数字组成的数组。

```python
X = np.array([5,6,7,8,9]) #创建1D张量，也就是向量
print("X的值",X)
print("X的阶",X.ndim) #ndim属性显示张量轴的个数
print("X的形状",X.shape) # shape属性显示张量形状

结果：
X的值 [5 6 7 8 9]
X的阶 1
X的形状 (5,)
```

**向量的点积**

```python
weight = np.array([1,-1.8,1,1,2]) # 权重向量(也就是多项式的参数)
X = np.array([1,6,7,8,9]) # 特征向量(也就是一个特定样本中的特征值)
y_hat = np.dot(X,weight) # 通过点积运算构建预测函数
print('函数返回结果:', y_hat) # 输出预测结果

结果：
函数返回结果: 23.2

# y_hat = weight.dot(X) 或 y_hat = X.dot(weight)也可以实现同样结果
```

### 矩阵——2D（阶）张量

**矩阵**：一组一组向量的集合。

矩阵的形状为（**样本，特征**）。第一个轴是**样本轴**，第二个轴是**特征轴**。

```python
X = np.array([[1,2,3,4,5],
             [2,3,4,5,6],
             [3,4,5,6,7],
             [4,5,6,7,8],
             [5,6,7,8,9]])
print("X的内容：", X) #X是2D张量，即矩阵

结果：
X_train的内容： 
[[1 2 3 4 5]
 [2 3 4 5 6]
 [3 4 5 6 7]
 [4 5 6 7 8]
 [5 6 7 8 9]]
```

**矩阵的点积**

```python
X = np.array([[1,2,3,4,5],
             [2,3,4,5,6],
             [3,4,5,6,7],
             [4,5,6,7,8],
             [5,6,7,8,9]])

Y = np.array([[2,3,4,5,6],
             [3,4,5,6,7],
             [4,5,6,7,8],
             [5,6,7,8,9],
             [6,7,8,9,10]])

Z = np.dot(X, Y)
print("Z的内容：", Z) 

结果：
Z的内容： 
[[ 70  85 100 115 130]
 [ 90 110 130 150 170]
 [110 135 160 185 210]
 [130 160 190 220 250]
 [150 185 220 255 290]]
```

### 序列数据——3D（阶）张量

```python
# 创建3D张量
X = np.array([[[1, 22, 4, 78, 2],
               [2, 59, 6, 56, 1],
               [3, 31, 8, 54, 0]],
              [[4, 56, 9, 34, 1],
               [5, 78, 8, 35, 2],
               [6, 34, 7, 36, 0]],
              [[7, 45,5, 34, 5],
               [8, 53, 6, 35, 4],
               [9, 81, 4, 36, 5]]])
```

时序数据集的形状为：（**样本，时戳，标签**）。  
文字序列集的形状为：（**样本，序号，字编码**）。

### 图像数据——4D（阶）张量

图像的形状为：（**样本，图像高度，图像宽度，颜色深度**）

例如：指定批量大小为 64，每批的 100px * 100px 的彩色图像张量形状为 (64, 64, 100, 3)  
如果是灰度图像，则为(64, 100, 100, 1)。

### 视频数据——5D（阶）张量

视频可以看做由一帧一帧的彩色图像组成的数据集。

* 每一帧都保存在一个形状为（高度，宽度，颜色，颜色深度）的 3D 张量中。
* 一系列帧则保存在一个形状为（帧，高度，宽度，颜色深度）的 3D 张量中。

视频数据集形状为（**样本，帧，高度，宽度，颜色深度**）

## 张量运算

### 创建张量

```python
import numpy as np # 导入NumPy数学工具集
list=[1,2,3,4,5] # 创建列表
array_01=np.array([1,2,3,4,5]) # 列表转化成数组
array_02=np.array((6,7,8,9,10)) # 元组转化成数组
array_03=np.array([[1,2,3],[4,5,6]]) # 列表转化成2D数组
print ('列表：', list)
print ('列表转化为数组：', array_01)
print ('元组转化为数组：', array_02)
print ('2D数组：', array_03)
print ('数组的形状：', array_01.shape)

结果：
列表： [1, 2, 3, 4, 5]
列表转化为数组： [1 2 3 4 5]
元组转化为数组： [ 6  7  8  9 10]
2D数组： 
[[1 2 3]
 [4 5 6]]
数组的形状： (5,)

array_04=np.arange(1,5,1) # 通过arange函数生成数组
array_05=np.linspace(1,5,5) # 通过linspace函数生成数组
print (array_04)
print (array_05)

结果：
[1 2 3 4]
[1. 2. 3. 4. 5.]
```

### 访问张量中的数据

可以通过**索引**和**切片**两种方式访问张量。索引就是访问整个数据集张量里面的某个具体数据；切片就是放一个范围内的数据。

```python
array_06 = np.arange(10)
print (array_06)
index_01 = array_06[3] # 索引-第4个元素
print ('第4个元素', index_01)
index_02 = array_06[-1] # 索引-最后一个元素
print ('第-1个元素', index_02)
slice_01 = array_06[:4] # 从0到4切片
print ('从0到4切片', slice_01)
slice_02 = array_06[0:12:4] # 从0到12切片，步长为2
print ('从0到12切片，步长为4', slice_02)

结果：
[0 1 2 3 4 5 6 7 8 9]
第4个元素 3
第-1个元素 9
从0到4切片 [0 1 2 3]
从0到12切片，步长为4 [0 4 8]


array_07 = np.array([[1,2,3],[4,5,6]])
print (array_07[1:2],'它的形状是', array_07[1:2].shape) 
print (array_07[1:2][0], '它的形状又不同了', array_07[1:2][0].shape)

结果：
[[4 5 6]] 它的形状是 (1, 3)
[4 5 6] 它的形状又不同了 (3, )
```

### 张量的变形和转置

```python
array_07 = np.array([[1,2,3],
           [4,5,6]])
print (array_07,'形状是', array_07.shape)
结果：
[[1 2 3]
 [4 5 6]] 形状是 (2, 3)

array_07 = array_07.reshape(3,2) # 矩阵的变形
print (array_07, '形状是', array_07.shape)
结果：
[[1 2]
 [3 4]
 [5 6]] 形状是 (3, 2)

array_07 = array_07.T # 矩阵的转置
print (array_07, '形状是', array_07.shape)
结果：
[[1 2 3]
 [4 5 6]] 形状是 (2, 3)
```

### Python 中的广播

```python
array_08 = np.array([[0,0,0], [10,10,10], [20,20,20], [30,30,30]])
print ('array_08的形状:', array_08.shape )
array_09 = np.array([[0,1,2]])
print ('array_09的形状:', array_09.shape )
array_10 = np.array([[0],[1],[2],[3]])
print ('array_10的形状:', array_10.shape )
list_11 = [[0,1,2]]
array_12 = array_09.reshape(3)
print ('array_12的形状:', array_12.shape )
array_13 = np.array([1])
print ('array_13的形状:', array_13.shape )
array_14 = array_13.reshape(1,1)
print ('array_14的形状:', array_14.shape )
print ('08 + 09结果：',array_08 + array_09)
print ('08 + 10结果：',array_08 + array_10)
print ('08 + 11结果：',array_08 + list_11)
print ('08 + 12结果：',array_08 + array_12)
print ('08 + 13结果：',array_08 + array_13)
print ('08 + 14结果：',array_08 + array_14)

结果：
array_08的形状: (4, 3)
array_09的形状: (1, 3)
array_10的形状: (4, 1)
array_12的形状: (3,)
array_13的形状: (1,)
array_14的形状: (1, 1)
08 + 09结果： 
[[ 0  1  2]
 [10 11 12]
 [20 21 22]
 [30 31 32]]
08 + 10结果： 
[[ 0  0  0]
 [11 11 11]
 [22 22 22]
 [33 33 33]]
08 + 11结果： 
[[ 0  1  2]
 [10 11 12]
 [20 21 22]
 [30 31 32]]
08 + 12结果： 
[[ 0  1  2]
 [10 11 12]
 [20 21 22]
 [30 31 32]]
08 + 13结果： 
[[ 1  1  1]
 [11 11 11]
 [21 21 21]
 [31 31 31]]
08 + 14结果： 
[[ 1  1  1]
 [11 11 11]
 [21 21 21]
 [31 31 31]]
```

广播的规则：

```
对两个数组，从后向前比较它们的每一个阶（若其中一个数组没有当前阶则忽略此阶的运算）
对于每一个阶，检查是否满足下列条件：
if 当前阶的维度相等
	then 可以直接进行算数操作；
else if 当前阶的维度不相等，但其中一个的值是 1
	then 通过广播将值为 1 的维度进行复制（拉伸），进行算数操作；
else if, 上述条件都不满足，那么两个数组当前阶不兼容，不能够进行广播操作
	then 抛出 "ValueError: operands could not be broadcast together" 异常;
```

## 点积运算

**向量的点积运算**

* 形状为 (n, ) 和形状为 (n, ) 的 1D 向量可以进行点积——结果是一个标量，即数字。
* 形状为 (n, ) 的 1D 向量和形状为 (1,n) 的 2D 张量可以进行点积——结果是一个 1D 形状的数字。
* 形状为 (1, n) 的 2D 向量和形状为 (n, ) 的 1D 张量可以进行点积——结果是一个 1D 形状的数字。
* 形状为 (1, n) 和形状为 (n,1) 的 2D 张量可以进行点积——结果是一个 1D 形状的数字。
* 形状为 (1, n) 和形状为 (1,n) 的 2D 张量不能进行点积。
* 形状为 (n, 1) 和形状为 (n,1) 的 2D 张量不能进行点积。
* 形状为 (n, ) (n, 1) (1, n) 的张量和形状为 (1, ) 的向量或者标量也可以进行点积，但结果会有所不同。

```python
vector_01 = np.array([1,2,3])
vector_02 = np.array([[1],[2],[3]])
vector_03 = np.array([2])
vector_04 = vector_02.reshape(1,3)
print ('vector_01的形状:', vector_01.shape)
print ('vector_02的形状:', vector_02.shape)
print ('vector_03的形状:', vector_03.shape)
print ('vector_04的形状:', vector_04.shape)
print ('01和01的点积:', np.dot(vector_01,vector_01))
print ('01和02的点积:', np.dot(vector_01,vector_02))
print ('04和02的点积:', np.dot(vector_04,vector_02))
print ('01和数字的点积:', np.dot(vector_01,2))
print ('02和03的点积:', np.dot(vector_02,vector_03))
print ('02和04的点积:', np.dot(vector_02,vector_04))
# print ('01和03的点积:', np.dot(vector_01,vector_03)) # 程序会报错
# print ('02和02的点积:', np.dot(vector_02,vector_02)) # 程序会报错

结果：
vector_01的形状: (3,)
vector_02的形状: (3, 1)
vector_03的形状: (1,)
vector_04的形状: (1, 3)
01和01的点积: 14
01和02的点积: [14]
04和02的点积: [[14]]
01和数字的点积: [2 4 6]
02和03的点积: [2 4 6]
02和04的点积: 
[[1 2 3]
 [2 4 6]
 [3 6 9]]
```

**矩阵的点积运算**

```python
matrix_01 = np.arange(0,6).reshape(2,3)
matrix_02 = np.arange(0,6).reshape(3,2)
print(matrix_01)
print(matrix_02)
print ('01和02的点积:', np.dot(matrix_01,matrix_02))
print ('02和01的点积:', np.dot(matrix_02,matrix_01))
print ('01和01的点积:', np.dot(matrix_01,matrix_01))

结果：
[[0 1 2]
 [3 4 5]]
[[0 1]
 [2 3]
 [4 5]]
01和02的点积: 
[[10 13]
 [28 40]]
02和01的点积: 
[[ 3  4  5]
 [ 9 14 19]
 [15 24 33]]
```

## 损失函数

* 用于回归的损失函数
  * 均方误差函数 (MSE)，L2 损失函数
  * 平均绝对误差函数，L1 损失函数
  * 平均偏差误差函数
* 用于分类的损失函数
  * 交叉熵损失函数
  * 多分类 SVM 损失函数